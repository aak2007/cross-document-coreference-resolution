package edu.oregonstate.domains.eecb.reader;

import edu.stanford.nlp.ie.machinereading.common.StringDictionary;
import edu.stanford.nlp.trees.Span;

/**
 * Every Token in the EECB corpus
 * 
 * @author Jun Xie (xie@eecs.oregonstate.edu)
 *
 */
public class EecbToken {

	/** the actual token bytes
	 * Normally we work with mWord (see below), but mLiteral is needed when
	 * we need to check if a sequence of tokens exists in a gazetteer 
	 */
	private String mLiteral;
	
	/** The index of the literal in the WORDS hash */
	private int mWord;
	
	private int mPos;

	private int mChunk;

	private Span mByteOffset;
	
	private int mSentence;
	
	/** Dictionary for all words in the corpus */
	public static StringDictionary WORDS;

	/** Dictionary for all lemmas in the corpus */
	public static StringDictionary LEMMAS;

	/** Dictionary for all other strings in the corpus */
	public static StringDictionary OTHERS;
	
	static {
	    WORDS = new StringDictionary("words");
	    LEMMAS = new StringDictionary("lemmas");
	    OTHERS = new StringDictionary("others");
	    WORDS.setMode(true);
	    LEMMAS.setMode(true);
	    OTHERS.setMode(true);	
	}
	
	public int getSentence() {
	    return mSentence;
	}
	
	public String getLiteral() {
	    return mLiteral;
	}
	
	public int getPos() {
	    return mPos;
	}

	public int getChunk() {
	    return mChunk;
	}
	
	public Span getByteOffset() {
	    return mByteOffset;
	}

	public int getByteStart() {
	    return mByteOffset.start();
	}

	public int getByteEnd() {
	    return mByteOffset.end();
	}
	
	public static String removeSpaces(String s) {
	    if (s == null)
	      return s;
	    return s.replaceAll(" ", "_");
	}
	
	/**
	 * Constructs an AceToken from a tokenized line generated by Tokey
	 */
	public EecbToken(String word, String pos, String chunk, String start, String end, int sentence) {
	    mLiteral = word;
	    if (word == null) {
	        mWord = -1;
	    } else {
	        mWord = WORDS.get(removeSpaces(word), false);
	    }
	    if (pos == null)
	        mPos = -1;
	    else
	        mPos = OTHERS.get(pos, false);
	    if (chunk == null)
	        mChunk = -1;
	    else
	        mChunk = OTHERS.get(chunk, false);
	    if (start != null && end != null) {
	    	mByteOffset = new Span(Integer.parseInt(start), Integer.parseInt(end));
	    }
	    mSentence = sentence;
	}
	
	/** Pretty display */
	public String display() {
	    if (mByteOffset != null) {
	      return new String("['" + WORDS.get(mWord) + "', " + OTHERS.get(mPos) + ", " + mByteOffset.start() + ", "
	          + mByteOffset.end() + "]");
	    }

	    return new String("['" + WORDS.get(mWord) + "', " + OTHERS.get(mPos) + "]");
	}

	@Override
	public String toString() {
		return display();
	}
	
}